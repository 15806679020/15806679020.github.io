<!DOCTYPE HTML>
<html lang="zh-CN">
    <!--  DongLiu  modify 2020.08.15-->



<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="JAVA面试题, 陌生的小窝">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY">
    <meta name="description" content="一、集合框架Java 集合类框架的基本接口有哪些？集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它 自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。
Java 集合类提供了一套设计良好的支">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JAVA面试题 | 陌生的小窝</title>
    <!-- <link rel="icon" type="image/png" href="avatar.jpg"> -->

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/materialize/1.0.0/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/aos/3.0.0-beta.6/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/lightgallery/1.6.12/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <style type="text/css">
        
            code[class*="language-"],
            pre[class*="language-"] {
                white-space: pre !important;
            }

        
    </style>

    <script src="https://libs.baidu.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
    

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

    <body>

        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    <span class="logo-span">陌生的小窝</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/AV" class="waves-effect waves-light">
            
            <i class="fa fa-music"></i>
            
            <span>视听</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于我</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 DongLiu  modify 2020.09.17  -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/" class="waves-effect waves-light">
              
                <i class="fa fa-home"></i>
              
              <span>首页</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/tags" class="waves-effect waves-light">
              
                <i class="fa fa-tags"></i>
              
              <span>标签</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/categories" class="waves-effect waves-light">
              
                <i class="fa fa-bookmark"></i>
              
              <span>分类</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/archives" class="waves-effect waves-light">
              
                <i class="fa fa-archive"></i>
              
              <span>归档</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/AV" class="waves-effect waves-light">
              
                <i class="fa fa-music"></i>
              
              <span>视听</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/about" class="waves-effect waves-light">
              
                <i class="fa fa-user-circle-o"></i>
              
              <span>关于我</span>
            </a>

            
      </li>
    

    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        <div class="logo-name">陌生的小窝</div>
        <div class="logo-desc">
            
            喜悦，是穿过重重荆棘之后的一泓清泉
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/AV" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-music"></i>
                
                视听
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于我
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/15806679020/15806679020.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

   
   
<!-- 支持二级菜单特性 DongLiu  modify 2020.09.17  -->
<!-- <ul class="menu-list mobile-menu-list">
    
        <li class="m-nav-item">
                
                    <a href="/" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/tags" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-tags"></i>
                        
                        标签
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/categories" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/archives" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/AV" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-music"></i>
                        
                        视听
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/about" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-user-circle-o"></i>
                        
                        关于我
                    </a>
              
            </li>
        

        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/15806679020/15806679020.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul> -->

</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/15806679020/15806679020.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

        
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        JAVA面试题
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!--  DongLiu  modify 2020.08.15-->
<!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/JAVA/" target="_blank">
                            <span class="chip bg-color">JAVA</span>
                        </a>
                        
                        <a href="/tags/面试题/" target="_blank">
                            <span class="chip bg-color">面试题</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/JAVA/" class="post-category" target="_blank">
                            JAVA
                        </a>
                        
                        <a href="/categories/JAVA/面试题/" class="post-category" target="_blank">
                            面试题
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-06
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    DongLiu
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    17.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    61 分
                </div>
                
                

                
                <span id="busuanzi_container_site_pv" style='display:none'></span>
                <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                <span id="busuanzi_value_page_pv"></span>

                

            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="一、集合框架"><a href="#一、集合框架" class="headerlink" title="一、集合框架"></a>一、集合框架</h4><h5 id="Java-集合类框架的基本接口有哪些？"><a href="#Java-集合类框架的基本接口有哪些？" class="headerlink" title="Java 集合类框架的基本接口有哪些？"></a>Java 集合类框架的基本接口有哪些？</h5><pre class="line-numbers language-test"><code class="language-test">集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它 自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。
Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面 最基本的接口有：
Collection：代表一组对象，每一个对象都是它的子元素。
Set：不包含重复元素的 Collection。
List：有顺序的 collection，并且可以包含重复元素。
Map：可以把键 (key) 映射到值 (value) 的对象，键不能重复。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="Set-里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是-equals-它们有何区别"><a href="#Set-里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是-equals-它们有何区别" class="headerlink" title="Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?"></a>Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?</h5><pre><code>Set 里的元素是不能重复的，元素重复与否是使用 equals() 方法进行判断的。
equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</code></pre><h5 id="两个对象值相同-x-equals-y-true-，但却可以有不同的-hash-code，这句话对不对"><a href="#两个对象值相同-x-equals-y-true-，但却可以有不同的-hash-code，这句话对不对" class="headerlink" title="两个对象值相同 (x.equals(y) == true)，但却可以有不同的 hash code，这句话对不对?"></a>两个对象值相同 (x.equals(y) == true)，但却可以有不同的 hash code，这句话对不对?</h5><pre><code>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode 值就必须相等。
如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode 不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实现，通常都会去实现的。</code></pre><h5 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h5><pre><code>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。
Array 大小是固定的，ArrayList 的大小是动态变化的。
ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。</code></pre><h5 id="HashSet-和-TreeSet-有什么区别？"><a href="#HashSet-和-TreeSet-有什么区别？" class="headerlink" title="HashSet 和 TreeSet 有什么区别？"></a>HashSet 和 TreeSet 有什么区别？</h5><pre><code>HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains()
TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains() 方法的时间复杂度是 O(logn)。</code></pre><h5 id="ArrayList-和-Vector-有什么区别？"><a href="#ArrayList-和-Vector-有什么区别？" class="headerlink" title="ArrayList 和 Vector 有什么区别？"></a>ArrayList 和 Vector 有什么区别？</h5><pre><code>ArrayList 与 Vector 的区别，这主要包括两个方面
同步性：
Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。
备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住 Vector 与 Hashtable是线程安全的，ArrayList 与 HashMap 是线程不安全的。
数据增长：
ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。</code></pre><h5 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器 (Iterator)？"></a>什么是迭代器 (Iterator)？</h5><pre><code>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代 器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素, 但是不可以直接调用集合的 remove(Object Obj) 删除，可以通过迭代器的 remove() 方法删除。</code></pre><h5 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h5><pre><code>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。
Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。
ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</code></pre><h5 id="Comparable-和-Comparator-接口是干什么的？列出它们的区别。"><a href="#Comparable-和-Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="Comparable 和 Comparator 接口是干什么的？列出它们的区别。"></a>Comparable 和 Comparator 接口是干什么的？列出它们的区别。</h5><pre><code>Java 提供了只包含一个 compareTo() 方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
Java 提供了包含 compare() 和 equals() 两个方法的 Comparator 接口。compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals() 方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时 候，这个方法才返回 true。</code></pre><h5 id="Collection-和-Collections-的区别。"><a href="#Collection-和-Collections-的区别。" class="headerlink" title="Collection 和 Collections 的区别。"></a>Collection 和 Collections 的区别。</h5><pre><code>collection 是集合类的上级接口, 继承与它的接口主要是 set 和 list。
collections 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜索, 排序, 线程安全化等操作。</code></pre><h5 id="heap-和-stack-有什么区别。"><a href="#heap-和-stack-有什么区别。" class="headerlink" title="heap 和 stack 有什么区别。"></a>heap 和 stack 有什么区别。</h5><pre><code>Java 的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。
堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new 创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final 修饰后，放在堆中，而不是栈中。</code></pre><h4 id="二、Spring"><a href="#二、Spring" class="headerlink" title="二、Spring"></a>二、Spring</h4><h5 id="使用Spring-框架的好处是什么？"><a href="#使用Spring-框架的好处是什么？" class="headerlink" title="使用Spring 框架的好处是什么？"></a>使用Spring 框架的好处是什么？</h5><pre><code>轻量：Spring 是轻量的，基本的版本大约2MB
控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是
创建或查找依赖的对象们
面向切面的编程(AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服
务分开
容器：Spring 包含并管理应用中对象的生命周期和配置
MVC 框架：Spring 的WEB 框架是个精心设计的框架，是Web 框架的一个很好的
替代品
事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全
局事务（JTA）
异常处理： Spring 提供方便的API 把具体技术相关的异常（ 比如由JDBC ，
Hibernate or JDO 抛出的）转化为一致的unchecked 异常</code></pre><h5 id="什么是Spring-IOC-容器？"><a href="#什么是Spring-IOC-容器？" class="headerlink" title="什么是Spring IOC 容器？"></a>什么是Spring IOC 容器？</h5><pre><code>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</code></pre><h5 id="IOC-的优点是什么？"><a href="#IOC-的优点是什么？" class="headerlink" title="IOC 的优点是什么？"></a>IOC 的优点是什么？</h5><pre><code>IOC 或依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI 查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC 容器支持加载服务时的饿汉式初始化和懒加载。</code></pre><h5 id="什么是Spring-的依赖注入？"><a href="#什么是Spring-的依赖注入？" class="headerlink" title="什么是Spring 的依赖注入？"></a>什么是Spring 的依赖注入？</h5><pre><code>依赖注入，是IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，
但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把他们组装起来。</code></pre><h5 id="有哪些不同类型的IOC（依赖注入）方式？"><a href="#有哪些不同类型的IOC（依赖注入）方式？" class="headerlink" title="有哪些不同类型的IOC（依赖注入）方式？"></a>有哪些不同类型的IOC（依赖注入）方式？</h5><pre><code>构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。
Setter 方法注入：Setter 方法注入是容器通过调用无参构造器或无参static 工厂方法实例化bean 之后，调用该bean的setter 方法，即实现了基于setter 的依赖注入。
接口注入:</code></pre><h5 id="哪种依赖注入方式你建议使用，构造器注入，还是Setter-方法注入？"><a href="#哪种依赖注入方式你建议使用，构造器注入，还是Setter-方法注入？" class="headerlink" title="哪种依赖注入方式你建议使用，构造器注入，还是Setter 方法注入？"></a>哪种依赖注入方式你建议使用，构造器注入，还是Setter 方法注入？</h5><pre><code>你两种依赖方式都可以使用，构造器注入和Setter 方法注入。最好的解决方案是用构造器参数实现强制依赖，setter 方法实现可选依赖。</code></pre><h5 id="什么是Spring-beans？"><a href="#什么是Spring-beans？" class="headerlink" title="什么是Spring beans？"></a>什么是Spring beans？</h5><h5 id="一个Spring-Bean-定义包含什么？"><a href="#一个Spring-Bean-定义包含什么？" class="headerlink" title="一个Spring Bean 定义包含什么？"></a>一个Spring Bean 定义包含什么？</h5><pre><code>一个Spring Bean 的定义包含容器必知的所有配置元数据， 包括如何创建一个bean，它的生命周期详情及它的依赖。</code></pre><h5 id="如何给Spring-容器提供配置元数据？"><a href="#如何给Spring-容器提供配置元数据？" class="headerlink" title="如何给Spring 容器提供配置元数据？"></a>如何给Spring 容器提供配置元数据？</h5><pre><code>这里有三种重要的方法给Spring 容器提供配置元数据。
XML 配置文件。
基于注解的配置。
基于java 的配置。</code></pre><h5 id="你怎样定义类的作用域？"><a href="#你怎样定义类的作用域？" class="headerlink" title="你怎样定义类的作用域？"></a>你怎样定义类的作用域？</h5><pre><code>当定义一个&lt;bean&gt; 在Spring 里，我们还能给这个bean 声明一个作用域。它可以通过bean 定义中的scope 属性来定义。如，当Spring 要在需要的时候每次生产一个新的bean 实例，bean 的scope 属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例， 这个bean 的scope 属性必须设为singleton。</code></pre><h5 id="解释Spring-支持的几种bean-的作用域"><a href="#解释Spring-支持的几种bean-的作用域" class="headerlink" title="解释Spring 支持的几种bean 的作用域"></a>解释Spring 支持的几种bean 的作用域</h5><pre><code>Spring 框架支持以下五种bean 的作用域：
 singleton : bean 在每个Spring ioc 容器中只有一个实例。
 prototype：一个bean 的定义可以有多个实例。
 request：每次http 请求都会创建一个bean，该作用域仅在基于web 的Spring
ApplicationContext 情形下有效。
 session：在一个HTTP Session 中，一个bean 定义对应一个实例。该作用域
仅在基于web 的Spring ApplicationContext 情形下有效。
 global-session：在一个全局的HTTP Session 中，一个bean 定义对应一个实
例。该作用域仅在基于web 的Spring ApplicationContext 情形下有效。
 缺省的Spring bean 的作用域是Singleton。</code></pre><h5 id="Spring-框架中的单例bean-是线程安全的吗？"><a href="#Spring-框架中的单例bean-是线程安全的吗？" class="headerlink" title="Spring 框架中的单例bean 是线程安全的吗？"></a>Spring 框架中的单例bean 是线程安全的吗？</h5><pre><code>不，Spring 框架中的单例bean 不是线程安全的。</code></pre><h5 id="在Spring-中如何注入一个java-集合？"><a href="#在Spring-中如何注入一个java-集合？" class="headerlink" title="在Spring 中如何注入一个java 集合？"></a>在Spring 中如何注入一个java 集合？</h5><pre><code>Spring 提供以下几种集合的配置元素：
&lt;list&gt;类型用于注入一列值，允许有相同的值。
&lt;set&gt; 类型用于注入一组值，不允许有相同的值。
&lt;map&gt; 类型用于注入一组键值对，键和值都可以为任意类型。
&lt;props&gt;类型用于注入一组键值对，键和值都只能为String 类型。</code></pre><h5 id="什么是bean-装配？"><a href="#什么是bean-装配？" class="headerlink" title="什么是bean 装配？"></a>什么是bean 装配？</h5><pre><code>装配，或bean 装配是指在Spring 容器中把bean 组装到一起，前提是容器需要知道bean 的依赖关系，如何通过依赖注入来把它们装配到一起。</code></pre><h5 id="什么是bean-的自动装配？"><a href="#什么是bean-的自动装配？" class="headerlink" title="什么是bean 的自动装配？"></a>什么是bean 的自动装配？</h5><pre><code>Spring 容器能够自动装配相互合作的bean ， 这意味着容器不需要&lt;constructor-arg&gt;和&lt;property&gt;配置，能通过Bean 工厂自动处理bean 之间的协作。</code></pre><h5 id="解释不同方式的自动装配"><a href="#解释不同方式的自动装配" class="headerlink" title="解释不同方式的自动装配"></a>解释不同方式的自动装配</h5><pre><code>有五种自动装配的方式，可以用来指导Spring 容器用自动装配方式来进行依赖注入
no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。
byName：通过参数名自动装配，Spring 容器在配置文件中发现bean 的autowire属性被设置成byname，之后容器试图匹配、装配和该bean 的属性具有相同名字的bean。
byType：通过参数类型自动装配，Spring 容器在配置文件中发现bean 的autowire属性被设置成byType，之后容器试图匹配、装配和该bean 的属性具有相同类型的bean。如果有多个bean 符合条件，则抛出错误。
constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。
autodetect：首先尝试使用constructor 来自动装配，如果无法工作，则使用byType方式。</code></pre><h5 id="你可以在Spring-中注入一个null-和一个空字符串吗？"><a href="#你可以在Spring-中注入一个null-和一个空字符串吗？" class="headerlink" title="你可以在Spring 中注入一个null 和一个空字符串吗？"></a>你可以在Spring 中注入一个null 和一个空字符串吗？</h5><pre><code>可以</code></pre><h5 id="Required-注解"><a href="#Required-注解" class="headerlink" title="@Required 注解"></a>@Required 注解</h5><pre><code>这个注解表明bean 的属性必须在配置的时候设置，通过一个bean 定义的显式的属性值或通过自动装配， 若@Required 注解的bean 属性未被设置， 容器将抛出BeanInitializationException。</code></pre><h5 id="Autowired-注解"><a href="#Autowired-注解" class="headerlink" title="@Autowired 注解"></a>@Autowired 注解</h5><pre><code>@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required 一样，修饰setter 方法、构造器、属性或者具有任意名称和/或多个参数的PN 方法。</code></pre><h5 id="Qualifier-注解"><a href="#Qualifier-注解" class="headerlink" title="@Qualifier 注解"></a>@Qualifier 注解</h5><pre><code>当有多个相同类型的bean 却只有一个需要自动装配时， 将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的bean。</code></pre><h5 id="Spring-支持的事务管理类型"><a href="#Spring-支持的事务管理类型" class="headerlink" title="Spring 支持的事务管理类型"></a>Spring 支持的事务管理类型</h5><pre><code>Spring 支持两种类型的事务管理：
编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。
声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</code></pre><h5 id="Spring-框架的事务管理有哪些优点？"><a href="#Spring-框架的事务管理有哪些优点？" class="headerlink" title="Spring 框架的事务管理有哪些优点？"></a>Spring 框架的事务管理有哪些优点？</h5><pre><code>它为不同的事务API 如JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。
它为编程式事务管理提供了一套简单的API 而不是一些复杂的事务API 如
它支持声明式事务管理。
它和Spring 各种数据访问抽象层很好得集成。</code></pre><h5 id="你更倾向用那种事务管理类型？"><a href="#你更倾向用那种事务管理类型？" class="headerlink" title="你更倾向用那种事务管理类型？"></a>你更倾向用那种事务管理类型？</h5><pre><code>大多数Spring 框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，
虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。</code></pre><h5 id="解释AOP"><a href="#解释AOP" class="headerlink" title="解释AOP"></a>解释AOP</h5><pre><code>面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</code></pre><h5 id="在Spring-AOP-中，关注点和横切关注的区别是什么？"><a href="#在Spring-AOP-中，关注点和横切关注的区别是什么？" class="headerlink" title="在Spring AOP 中，关注点和横切关注的区别是什么？"></a>在Spring AOP 中，关注点和横切关注的区别是什么？</h5><pre><code>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。
横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</code></pre><h5 id="什么是Spring-的MVC-框架？"><a href="#什么是Spring-的MVC-框架？" class="headerlink" title="什么是Spring 的MVC 框架？"></a>什么是Spring 的MVC 框架？</h5><pre><code>Spring 配备构建Web 应用的全功能MVC 框架。Spring 可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC 框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</code></pre><h5 id="什么是Spring-MVC-框架的控制器？"><a href="#什么是Spring-MVC-框架的控制器？" class="headerlink" title="什么是Spring MVC 框架的控制器？"></a>什么是Spring MVC 框架的控制器？</h5><pre><code>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring 用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</code></pre><h5 id="Controller-注解"><a href="#Controller-注解" class="headerlink" title="@Controller 注解"></a>@Controller 注解</h5><pre><code>该注解表明该类扮演控制器的角色，Spring 不需要你继承任何其他控制器基类或引用Servlet API。</code></pre><h5 id="RequestMapping-注解"><a href="#RequestMapping-注解" class="headerlink" title="@RequestMapping 注解"></a>@RequestMapping 注解</h5><pre><code>该注解是用来映射一个URL 到一个类或一个特定的方处理法上。</code></pre><h4 id="三、SpringBoot"><a href="#三、SpringBoot" class="headerlink" title="三、SpringBoot"></a>三、SpringBoot</h4><h5 id="什么是Spring-Boot？"><a href="#什么是Spring-Boot？" class="headerlink" title="什么是Spring Boot？"></a>什么是Spring Boot？</h5><pre><code>多年来，随着新功能的增加，spring变得越来越复杂。只需访问https://spring.io/projects页面，我们就会看到可以在我们的应用程序中使用的所有Spring项目的不同功能。如果必须启动一个新的Spring项目，我们必须添加构建路径或添加Maven依赖关系，配置应用程序服务器，添加spring配置。因此，开始一个新的spring项目需要很多努力，因为我们现在必须从头开始做所有事情。
Spring Boot是解决这个问题的方法。Spring Boot已经建立在现有spring框架之上。使用spring启动，我们避免了之前我们必须做的所有样板代码和配置。因此，Spring Boot可以帮助我们以最少的工作量，更加健壮地使用现有的Spring功能。</code></pre><h5 id="Spring-Boot有哪些优点？"><a href="#Spring-Boot有哪些优点？" class="headerlink" title="Spring Boot有哪些优点？"></a>Spring Boot有哪些优点？</h5><pre><code>Spring Boot的优点有：
减少开发，测试时间和努力。
使用JavaConfig有助于避免使用XML。
避免大量的Maven导入和各种版本冲突。
提供意见发展方法。
通过提供默认值快速开始开发。
没有单独的Web服务器需要。这意味着你不再需要启动Tomcat，Glassfish或其他任何东西。
需要更少的配置 因为没有web.xml文件。只需添加用@ Configuration注释的类，然后添加用@Bean注释的方法，Spring将自动加载对象并像以前一样对其进行管理。您甚至可以将@Autowired添加到bean方法中，以使Spring自动装入需要的依赖关系中。
基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应用程序属性文件后，Spring将在（application{environment} .properties）中加载后续的应用程序属性文件。</code></pre><h5 id="什么是JavaConfig？"><a href="#什么是JavaConfig？" class="headerlink" title="什么是JavaConfig？"></a>什么是JavaConfig？</h5><pre><code>Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：
面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。
减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人
员不希望在XML和Java之间来回切换。JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。
类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。</code></pre><h5 id="Spring-Boot中的监视器是什么？"><a href="#Spring-Boot中的监视器是什么？" class="headerlink" title="Spring Boot中的监视器是什么？"></a>Spring Boot中的监视器是什么？</h5><pre><code>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</code></pre><h5 id="什么是YAML？"><a href="#什么是YAML？" class="headerlink" title="什么是YAML？"></a>什么是YAML？</h5><pre><code>YAML是一种人类可读的数据序列化语言。它通常用于配置文件。
与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆。可以看出YAML具有分层配置数据。</code></pre><h5 id="如何实现Spring-Boot应用程序的安全性？"><a href="#如何实现Spring-Boot应用程序的安全性？" class="headerlink" title="如何实现Spring Boot应用程序的安全性？"></a>如何实现Spring Boot应用程序的安全性？</h5><pre><code>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</code></pre><h5 id="什么是Swagger？你用Spring-Boot实现了它吗？"><a href="#什么是Swagger？你用Spring-Boot实现了它吗？" class="headerlink" title="什么是Swagger？你用Spring Boot实现了它吗？"></a>什么是Swagger？你用Spring Boot实现了它吗？</h5><pre><code>Swagger广泛用于可视化API，使用Swagger UI为前端开发人员提供在线沙箱。Swagger是
用于生成RESTful Web服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</code></pre><h5 id="什么是Spring-Profiles？"><a href="#什么是Spring-Profiles？" class="headerlink" title="什么是Spring Profiles？"></a>什么是Spring Profiles？</h5><pre><code>Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot使得使用配置文件非常简单。</code></pre><h5 id="什么是Spring-Batch？"><a href="#什么是Spring-Batch？" class="headerlink" title="什么是Spring Batch？"></a>什么是Spring Batch？</h5><pre><code>Spring Boot Batch提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志/跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</code></pre><h5 id="如何使用Spring-Boot实现异常处理？"><a href="#如何使用Spring-Boot实现异常处理？" class="headerlink" title="如何使用Spring Boot实现异常处理？"></a>如何使用Spring Boot实现异常处理？</h5><pre><code>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。 我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常。</code></pre><h5 id="什么是CSRF攻击？"><a href="#什么是CSRF攻击？" class="headerlink" title="什么是CSRF攻击？"></a>什么是CSRF攻击？</h5><pre><code>CSRF代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web应用程序上执行不需要的操作。CSRF攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</code></pre><h4 id="四、SpringCloud"><a href="#四、SpringCloud" class="headerlink" title="四、SpringCloud"></a>四、SpringCloud</h4><h5 id="什么是Spring-Cloud？"><a href="#什么是Spring-Cloud？" class="headerlink" title="什么是Spring Cloud？"></a>什么是Spring Cloud？</h5><pre><code>Spring cloud流应用程序启动器是基于Spring Boot的Spring集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</code></pre><h5 id="使用Spring-Cloud有什么优势？"><a href="#使用Spring-Cloud有什么优势？" class="headerlink" title="使用Spring Cloud有什么优势？"></a>使用Spring Cloud有什么优势？</h5><pre><code>使用Spring Boot开发分布式微服务时，我们面临以下问题
与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。
服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。
冗余-分布式系统中的冗余问题。
负载均衡 --负载均衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。
性能-问题 由于各种运营开销导致的性能问题。
部署复杂性-Devops技能的要求。</code></pre><h5 id="服务注册和发现是什么意思？Spring-Cloud如何实现？"><a href="#服务注册和发现是什么意思？Spring-Cloud如何实现？" class="headerlink" title="服务注册和发现是什么意思？Spring Cloud如何实现？"></a>服务注册和发现是什么意思？Spring Cloud如何实现？</h5><pre><code>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka服务注册和发现可以在这种情况下提供帮助。由于所有服务都在Eureka服务器上注册并通过调用Eureka服务器完成查找，因此无需处理服务地点的任何更改和处理。</code></pre><h5 id="负载均衡的意义什么？"><a href="#负载均衡的意义什么？" class="headerlink" title="负载均衡的意义什么？"></a>负载均衡的意义什么？</h5><pre><code>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</code></pre><h5 id="什么是Hystrix？"><a href="#什么是Hystrix？" class="headerlink" title="什么是Hystrix？"></a>什么是Hystrix？</h5><pre><code>Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</code></pre><h5 id="什么是Hystrix断路器？"><a href="#什么是Hystrix断路器？" class="headerlink" title="什么是Hystrix断路器？"></a>什么是Hystrix断路器？</h5><h4 id="五、SpringCloudAlibaba"><a href="#五、SpringCloudAlibaba" class="headerlink" title="五、SpringCloudAlibaba"></a>五、SpringCloudAlibaba</h4><h5 id="为什么要选择AlibabaCloud-和SpringCloud的区别"><a href="#为什么要选择AlibabaCloud-和SpringCloud的区别" class="headerlink" title="为什么要选择AlibabaCloud , 和SpringCloud的区别"></a>为什么要选择AlibabaCloud , 和SpringCloud的区别</h5><pre><code>SpringCloud和AlibabaCloud组件存在很大交集，互相配合
SpringCloud很多组件是基于第三方整合，目前多个已经不更新了了，比如zuul、eureka、hystrix等
AlibabaCloud 提供一站式微服务解决方法，已经和SpringCloud进行了整合，组件互相支持</code></pre><h5 id="AlibabaCloud全家桶介绍"><a href="#AlibabaCloud全家桶介绍" class="headerlink" title="AlibabaCloud全家桶介绍"></a>AlibabaCloud全家桶介绍</h5><pre><code>服务注册发现：Nacos
服务限流降级：Sentinel
分布配置中心：Nacos
服务网关：SpringCloud Gateway
服务之间调用：Feign、Ribbon
链路追踪：Sleuth+Zipkin</code></pre><h5 id="什么是注册中心和常见的注册中心有哪些"><a href="#什么是注册中心和常见的注册中心有哪些" class="headerlink" title="什么是注册中心和常见的注册中心有哪些"></a>什么是注册中心和常见的注册中心有哪些</h5><pre><code>什么是注册中心（服务治理）
服务注册：服务提供者provider，启动的时候向注册中心上报自己的网络信息
服务发现：服务消费者consumer,启动的时候向注册中心上报自己的网络信息，拉取provider的相关网络信息
核心:服务管理,是有个服务注册表，心跳机制动态维护，服务实例在启动时注册到服务注册表，并在关闭时注销。
为什么要用
微服务应用和机器越来越多，调用方需要知道接口的网络地址，如果靠配置文件的方式去控制网络地址，对于动态新增机器，维护带来很大问题
主流的注册中心：zookeeper、Eureka、consul、etcd、Nacos
AlibabaCloud搭配最好的是Nacos，且服务的注册发现之外，还支持动态配置服务</code></pre><h5 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h5><pre><code>分布式系统中一个非常重要的概念，当访问的服务具有多个实例时，需要根据某种“均衡”的策略略决定请求发往哪个节点，这就是所谓的负载均衡，
原理是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，从而提高了数据的吞吐量</code></pre><h5 id="常见的负载均衡策略"><a href="#常见的负载均衡策略" class="headerlink" title="常见的负载均衡策略"></a>常见的负载均衡策略</h5><pre><code>节点轮询
简介：每个请求按顺序分配到不同的后端服务器
weight 权重配置
简介：weight和访问比率成正比，数字越大，分配得到的流量越高
固定分发
简介：根据请求按访问ip的hash结果分配，这样每个用户就可以固定访问一个后端服务器</code></pre><h5 id="分布式应用核心CAP知识"><a href="#分布式应用核心CAP知识" class="headerlink" title="分布式应用核心CAP知识"></a>分布式应用核心CAP知识</h5><pre><code>CAP定理: 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）

三者不可同时获得
一致性（C）：所有节点都可以访问到最新的数据，在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完
全一致，越多节点，数据同步越耗时）
强一致性（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。
单调一致性（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。
会话一致性（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这值更旧的值会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。
最终一致性（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。
弱一致性（weak consistency）。用户无法在确定时间内读到最新更新的值。
可用性（A）：每个请求都是可以得到响应的，不管请求是成功还是失败。负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间）
分区容错性（P）：除了全部整体网络故障，其他故障都不能导致整个系统不可用。分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）
CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡
CA： 如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的
CP: 如果不要求A（可用），每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统
AP：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</code></pre><h5 id="CAP下的注册中心选择"><a href="#CAP下的注册中心选择" class="headerlink" title="CAP下的注册中心选择"></a>CAP下的注册中心选择</h5><pre><code>Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足

Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点

Nacos:CP+AP
结论：

分布式系统中P,肯定要满足，所以只能在CA中二选一
没有最好的选择，最好的选择是根据业务场景来进行架构设计
如果要求一致性，则选择zookeeper/Nacos，如金融行业CP
如果要求可用性，则Eureka/Nacos，如电商系统 AP
CP ： 适合支付、交易类，要求数据强一致性，宁可业务不可用，也不能出现脏数据
AP: 互联网业务，比如信息流架构，不要求数据强一致，更想要服务可用</code></pre><h5 id="Docker容器常见命令"><a href="#Docker容器常见命令" class="headerlink" title="Docker容器常见命令"></a>Docker容器常见命令</h5><pre><code>搜索镜像：docker search xxx
列出当前系统存在的镜像：docker images
拉取镜像：docker pull xxx
列举当前运行的容器：docker ps
检查容器内部信息：docker inspect 容器器名称
删除镜像：docker rmi IMAGE_NAME
强制移除镜像不管是否有容器使用该镜像 增加 -f 参数
停止某个容器：docker stop 容器名称
启动某个容器：docker start 容器名称
移除某个容器： docker rm 容器名称 （容器必须是停止状态）
列举全部 容器 ： docker ps -a</code></pre><h4 id="六、Dubbo"><a href="#六、Dubbo" class="headerlink" title="六、Dubbo"></a>六、Dubbo</h4><h5 id="Dubbo是什么？"><a href="#Dubbo是什么？" class="headerlink" title="Dubbo是什么？"></a>Dubbo是什么？</h5><pre><code>Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring框架无缝集成。</code></pre><h5 id="Dubbo的主要应用场景？"><a href="#Dubbo的主要应用场景？" class="headerlink" title="Dubbo的主要应用场景？"></a>Dubbo的主要应用场景？</h5><pre><code>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。
软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。
服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</code></pre><h5 id="Dubbo的核心功能？"><a href="#Dubbo的核心功能？" class="headerlink" title="Dubbo的核心功能？"></a>Dubbo的核心功能？</h5><pre><code>主要就是如下3个核心功能：
Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。
Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</code></pre><h5 id="Dubbo的核心组件？"><a href="#Dubbo的核心组件？" class="headerlink" title="Dubbo的核心组件？"></a>Dubbo的核心组件？</h5><h4 id="七、Zookeeper"><a href="#七、Zookeeper" class="headerlink" title="七、Zookeeper"></a>七、Zookeeper</h4><h4 id="八、MyBatis-plus"><a href="#八、MyBatis-plus" class="headerlink" title="八、MyBatis-plus"></a>八、MyBatis-plus</h4><h5 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h5><pre><code>#{}是预编译处理，${}是字符串替换。
Mybatis 在处理#{}时，会将sql 中的#{}替换为?号，调用PreparedStatement 的set方法来赋值；
Mybatis 在处理${}时，就是把${}替换成变量的值。
使用#{}可以有效的防止SQL 注入，提高系统安全性。</code></pre><h5 id="一级、二级缓存"><a href="#一级、二级缓存" class="headerlink" title="一级、二级缓存"></a>一级、二级缓存</h5><pre><code>1) 一级缓存: 基于PerpetualCache 的HashMap 本地缓存， 其存储作用域为Session，当Session flush 或close 之后，该Session 中的所有Cache 就将
清空。
2）二级缓存与一级缓存其机制相同，默认也是采用PerpetualCache，HashMap 存储， 不同在于其存储作用域为Mapper(Namespace)， 并且可自定义存储源， 如Ehcache。要开启二级缓存，你需要在你的SQL 映射文件中添加一行：&lt;cache/&gt;
3) 对于缓存数据更新机制， 当某一个作用域( 一级缓存Session/ 二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有select 中的缓存将被clear。</code></pre><h5 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h5><pre><code>Mybatis 仅支持association 关联对象和collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在Mybatis 配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。它的原理是，使用CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B 对象的sql，把B 查询上来，然后调用a.setB(b)，于是a 的对象b 属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</code></pre><h5 id="在mapper中如何传递多个参数？"><a href="#在mapper中如何传递多个参数？" class="headerlink" title="在mapper中如何传递多个参数？"></a>在mapper中如何传递多个参数？</h5><pre><code>直接在方法中传递参数，xml文件用#{0} #{1}来获取
使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取</code></pre><h5 id="resultType-resultMap的区别？"><a href="#resultType-resultMap的区别？" class="headerlink" title="resultType resultMap的区别？"></a>resultType resultMap的区别？</h5><pre><code>类的名字和数据库相同时，可以直接设置resultType参数为Pojo类
若不同，需要设置resultMap 将结果名字和Pojo名字进行转换</code></pre><h5 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h5><pre><code>1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同
2）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同
3）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同
4）Mapper.xml文件中的namespace即是mapper接口的类路径。</code></pre><p>九、MySQL</p>
<h5 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h5><pre><code>原子性Atomicity：
一个事务必须被事务不可分割的最小⼯作单元，整个操作要么全部成功，要么全部失败，一般就是通过commit和rollback来控制
一致性Consistency:
数据库总能从一个一致性的状态转换到另一个一致性的状态
隔离性Isolation:
一个事务相对于另一个事务是隔离的，一个事务所做的修改是在最终提交以前，对其他事务是不可⻅的
持久性Durability:
一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失</code></pre><h5 id="Mysql中InnoDB支持的四种事务隔离级别名称"><a href="#Mysql中InnoDB支持的四种事务隔离级别名称" class="headerlink" title="Mysql中InnoDB支持的四种事务隔离级别名称"></a>Mysql中InnoDB支持的四种事务隔离级别名称</h5><pre><code>SQL标准定义的四个隔离级别为：
read uncommited ：读到未提交数据
read committed：脏读，不可重复读
repeatable read：可重读
serializable ：串行事物</code></pre><h5 id="CHAR和VARCHAR的区别？"><a href="#CHAR和VARCHAR的区别？" class="headerlink" title="CHAR和VARCHAR的区别？"></a>CHAR和VARCHAR的区别？</h5><pre><code>CHAR和VARCHAR类型在存储和检索方面有所不同
CHAR列长度固定为创建表时声明的长度，长度值范围是1到255
当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</code></pre><h5 id="Mysql查询是否区分大小写？"><a href="#Mysql查询是否区分大小写？" class="headerlink" title="Mysql查询是否区分大小写？"></a>Mysql查询是否区分大小写？</h5><pre><code>不区分</code></pre><h5 id="Mysql中有哪几种锁"><a href="#Mysql中有哪几种锁" class="headerlink" title="Mysql中有哪几种锁"></a>Mysql中有哪几种锁</h5><pre><code>MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁
表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低
行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</code></pre><h5 id="有哪些sql优化方面的经验"><a href="#有哪些sql优化方面的经验" class="headerlink" title="有哪些sql优化方面的经验"></a>有哪些sql优化方面的经验</h5><pre><code>1）应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 
2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
3）当只要一行数据时使用 LIMIT 1
4）为搜索字段建索引
5）尽可能的使用 NOT NULL
6）</code></pre><h5 id="请简述常用的索引有哪些种"><a href="#请简述常用的索引有哪些种" class="headerlink" title="请简述常用的索引有哪些种"></a>请简述常用的索引有哪些种</h5><pre><code>普通索引: 即针对数据库表创建索引
唯一索引: 与普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值
主键索引: 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引
组合索引: 为了进一步榨取MySQL的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</code></pre><h5 id="mysql中myisam与innodb的区别？"><a href="#mysql中myisam与innodb的区别？" class="headerlink" title="mysql中myisam与innodb的区别？"></a>mysql中myisam与innodb的区别？</h5><pre><code>1.事务支持 &gt; MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 &gt; InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
2.InnoDB支持行级锁，而MyISAM支持表级锁. &gt;&gt; 用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
3.InnoDB支持MVCC, 而MyISAM不支持
4.InnoDB支持外键，而MyISAM不支持
5.表主键 &gt; MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 &gt; InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
6.InnoDB不支持全文索引，而MyISAM支持。
7.可移植性、备份及恢复 &gt; MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 &gt; InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了
8.存储结构 &gt; MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。 &gt; InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</code></pre><h5 id="SELECT-和-SELECT-全部字段-的2种写法有何优缺点"><a href="#SELECT-和-SELECT-全部字段-的2种写法有何优缺点" class="headerlink" title="[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?"></a>[SELECT *] 和[SELECT 全部字段]的2种写法有何优缺点?</h5><pre><code>1.前者要解析数据字典，后者不需要
2.结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。
3.表字段改名，前者不需要修改，后者需要改
4.后者可以建立索引进行优化，前者无法优化
5.后者的可读性比前者要高</code></pre><h5 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h5><pre><code>drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。
（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。
（3） 一般而言，drop &gt; truncate &gt; delete
（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view
（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。
（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚
（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。
（10） Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE
通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。
（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</code></pre><h5 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h5><pre><code>悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
两种锁的使用场景
从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</code></pre><h5 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h5><pre><code>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</code></pre><h4 id="十、Oracle"><a href="#十、Oracle" class="headerlink" title="十、Oracle"></a>十、Oracle</h4><h4 id="十一、Redis"><a href="#十一、Redis" class="headerlink" title="十一、Redis"></a>十一、Redis</h4><h5 id="Redis支持哪几种数据类型？"><a href="#Redis支持哪几种数据类型？" class="headerlink" title="Redis支持哪几种数据类型？"></a>Redis支持哪几种数据类型？</h5><pre><code>String、List、Set、Sorted Set、hashes</code></pre><h5 id="Redis有哪几种数据淘汰策略？"><a href="#Redis有哪几种数据淘汰策略？" class="headerlink" title="Redis有哪几种数据淘汰策略？"></a>Redis有哪几种数据淘汰策略？</h5><pre><code>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</code></pre><h5 id="Redis有哪些适合的场景？"><a href="#Redis有哪些适合的场景？" class="headerlink" title="Redis有哪些适合的场景？"></a>Redis有哪些适合的场景？</h5><pre><code>（1）会话缓存（Session Cache）
最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？
幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。
（2）全页缓存（FPC）
除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。
再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。
此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
（3）队列
Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。
（4）排行榜/计数器
Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。
所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：
当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
ZRANGE user_scores 0 10 WITHSCORES
Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。
（5）发布/订阅
最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！</code></pre><h5 id="redis能否将数据持久化，如何实现"><a href="#redis能否将数据持久化，如何实现" class="headerlink" title="redis能否将数据持久化，如何实现"></a>redis能否将数据持久化，如何实现</h5><pre><code>能，将内存中的数据异步写入硬盘中，两种方式：RDB（默认）和AOF
RDB持久化原理：通过bgsave命令触发，然后父进程执行fork操作创建子进程，子进程创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换（定时一次性将所有数据进行快照生成一份副本存储在硬盘中）
优点：是一个紧凑压缩的二进制文件，Redis加载RDB恢复数据远远快于AOF的方式。
缺点：由于每次生成RDB开销较大，非实时持久化，
AOF持久化原理：开启后，Redis每执行一个修改数据的命令，都会把这个命令添加到AOF文件中。
优点：实时持久化。
缺点：所以AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积，加载慢</code></pre><h5 id="如何防止缓存穿透"><a href="#如何防止缓存穿透" class="headerlink" title="如何防止缓存穿透"></a>如何防止缓存穿透</h5><pre><code>缓存穿透指的是查询一个根本不存在的数据，缓存层不命中，又去查存储层，又不命中。但如果有大量这种查询不存在的数据的请求过来，会对存储层有较大压力
布隆过滤器：
布隆过滤器存在的问题：相对来说布隆过滤器搞起来代码还是比较复杂的，现阶段我们暂时还不需要，后面实在需要再考虑去做，什么阶段做什么样的事情，不是说这个系统一下子就能做的各种完美。</code></pre><h5 id="能否说下缓存击穿、穿透、雪崩的区别？"><a href="#能否说下缓存击穿、穿透、雪崩的区别？" class="headerlink" title="能否说下缓存击穿、穿透、雪崩的区别？"></a>能否说下缓存击穿、穿透、雪崩的区别？</h5><pre><code>缓存击穿 (某个热点key缓存失效了)
    缓存中没有但数据库中有的数据，假如是热点数据，那key在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力增大。
    和缓存雪崩的区别在于这里针对某一key缓存，后者则是很多key。
    预防：设置热点数据不过期，定时任务定时更新缓存，或者设置互斥锁
缓存穿透（查询不存在数据）
    查询一个不存在的数据，由于缓存是不命中的，并且出于容错考虑，如发起为id为“-1”不存在的数据
    如果从存储层查不到数据则不写入缓存这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。存在大量查询不存在的数据，可能DB就挂掉了，这也是黑客利用不存在的key频繁攻击应用的一种方式。
    预防：接口层增加校验，数据合理性校验，缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，设置短点的过期时间，防止同个key被一直攻击
缓存雪崩 (多个热点key都过期)
    大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩
    预防：存数据的过期时间设置随机，防止同一时间大量数据过期现象发生，设置热点数据永远不过期，定时任务定时更新</code></pre><h4 id="十二、Nginx"><a href="#十二、Nginx" class="headerlink" title="十二、Nginx"></a>十二、Nginx</h4><h5 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx?"></a>什么是Nginx?</h5><pre><code>Nginx是一个web服务器和反向代理服务器，用于HTTP、HTTPS、SMTP、POP3和IMAP协议。</code></pre><h5 id="nginx是通过alias设置虚拟目录，在nginx的配置中，alias目录和root目录是有区别的"><a href="#nginx是通过alias设置虚拟目录，在nginx的配置中，alias目录和root目录是有区别的" class="headerlink" title="nginx是通过alias设置虚拟目录，在nginx的配置中，alias目录和root目录是有区别的"></a>nginx是通过alias设置虚拟目录，在nginx的配置中，alias目录和root目录是有区别的</h5><pre><code>alias指定的目录是准确的，即location匹配访问的path目录下的文件直接是在alias目录下查找的；
root指定的目录是location匹配访问的path目录的上一级目录,这个path目录一定要是真实存在root指定目录下的；
使用alias标签的目录块中不能使用rewrite的break；另外，alias指定的目录后面必须要加上”/“符号！！
alias虚拟目录配置中，location匹配的path目录如果后面不带”/“，那么访问的url地址中这个path目录后面加不加”/“不影响访问，访问时它会自动加上”/“；但是如果location匹配的path目录后面加上”/“，那么访问的url地址中这个path目录必须要加上”/“，访问时它不会自动加上”/“。如果不加上”/“，访问就会失败！
root目录配置中，location匹配的path目录后面带不带”/“，都不会影响访问。</code></pre><h5 id="Ngnix-LVS-KeepAlived-Nginx高可用解决方案"><a href="#Ngnix-LVS-KeepAlived-Nginx高可用解决方案" class="headerlink" title="Ngnix+LVS+KeepAlived  Nginx高可用解决方案"></a>Ngnix+LVS+KeepAlived  Nginx高可用解决方案</h5><pre><code>LVS是Linux Virtual Server,Linux虚拟服务器，是一个虚拟的服务器集群系统
提供了10多种调度算法： 轮询、加权轮询、最小连接、目标地址散列、源地址散列等
三种负载均衡转发技术
NAT：数据进出都通过 LVS, 前端的Master既要处理客户端发起的请求，又要处理后台RealServer的响应信息，将RealServer响应的信息再转发给客户端, 容易成为整个集群系统性能的瓶颈; (支持任意系统且可以实现端口映射)
DR: 移花接木,最高效的负载均衡规则,前端的Master只处理客户端的请求，将请求转发给RealServer，由后台的RealServer直接响应客户端，不再经过Master, 性能要优于LVS-NAT; 需要LVS和RS集群绑定同一个VIP（支持多数系统，不可以实现端口映射)
TUNL：隧道技术，前端的Master只处理客户端的请求，将请求转发给RealServer，然后由后台的RealServer直接响应客户端，不再经过Master；（支持少数系统，不可以实现端口映射）
keepalived

核心：监控并管理 LVS 集群系统中各个服务节点的状态

keepalived是一个类似于交换机制的软件,核心作用是检测服务器的状态，如果有一台web服务器工作出现故障，Keepalived将检测到并将有故障的服务器从系统中剔除，使用其他服务器代替该服务器的工作，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成。
后来加入了vrrp(虚拟路由器冗余协议)，除了为lvs提供高可用还可以为其他服务器比如Mysql、Haproxy等软件提供高可用方案</code></pre><h4 id="十三、多线程"><a href="#十三、多线程" class="headerlink" title="十三、多线程"></a>十三、多线程</h4><h5 id="什么是线程安全和线程不安全"><a href="#什么是线程安全和线程不安全" class="headerlink" title="什么是线程安全和线程不安全"></a>什么是线程安全和线程不安全</h5><pre><code>1、线程安全
线程安全: 就是多线程访问时，采⽤用了了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。
2、线程不安全
线程不不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据
线程安全问题都是由全局变量及静态变量引起的。
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</code></pre><h5 id="java里面实现多线程有哪几种方式，有什么不同，比较常用哪种"><a href="#java里面实现多线程有哪几种方式，有什么不同，比较常用哪种" class="headerlink" title="java里面实现多线程有哪几种方式，有什么不同，比较常用哪种"></a>java里面实现多线程有哪几种方式，有什么不同，比较常用哪种</h5><pre><code>1、继承Thread
继承Thread，重写里面run方法，创建实例，执行start
优点：代码编写最简单直接操作
缺点：没返回值，继承一个类后，没法继承其他的类，拓展性差
2、实现Runnable
自定义类实现Runnable，实现里面run方法，创建Thread类，使用Runnable接口的实现对象
作为参数传递给Thread对象，调⽤用Strat方法
优点：线程类可以实现多个几接口，可以再继承一个类
缺点：没返回值，不能直接启动，需要通过构造⼀个Thread实例传递进去启动
3、通过Callable和FutureTask⽅方式
创建callable接口的实现类，并实现call⽅方法，结合FutureTask类包装Callable对象，实现多线程
优点：有返回值，拓展性也高
4、通过线程池创建线程
自定义Runnable接口，实现run⽅方法，创建线程池，调用执行方法并传⼊对象
优点：安全高性能，复用线程</code></pre><h5 id="说说你在平时的开发中，如何使用线程池？"><a href="#说说你在平时的开发中，如何使用线程池？" class="headerlink" title="说说你在平时的开发中，如何使用线程池？"></a>说说你在平时的开发中，如何使用线程池？</h5><pre><code>平时使用线程池时，一般使用 new ThreadPoolExecutor 的方式去创建线程池：
通过new创建线程池时，除非调用prestartAllCoreThreads方法初始化核心线程，否则此时线程
池中有0个线程，即使工作队列中存在多个任务，同样不会执行
1：当任务数&lt;=核心线程数的时候，会创建于当前任务数相同的核心线程用于处理线程
2：当当前任务数 &gt;= 核心线程数&amp;&amp; 当前任务数 &lt; 工作队列容量 + 核心线程数 会启动设定的核心线程数个线程 其他的任务就放到工作队列里
3： 当前任务数 &gt; 工作队列容量+核心线程数的容量时，分两种情况
当当前任务数 - 工作队列容量 &lt;= 最大线程数 ，此时启动 （当当前任务数 - 工作队列容量）个线程
当当前任务数 - 核心线程数-工作队列容量 &gt; 最大线程数，会启动最大线程数数量的线程来处理</code></pre><h5 id="用过线程池不-有什么好处，-java里有哪些是常用的线程池"><a href="#用过线程池不-有什么好处，-java里有哪些是常用的线程池" class="headerlink" title="用过线程池不? 有什么好处， java里有哪些是常用的线程池"></a>用过线程池不? 有什么好处， java里有哪些是常用的线程池</h5><pre><code>好处：重用存在的线程，减少对象创建销毁的开销，有效的控制最大并发线程数，提高系统资源的使用率，同
时避免过多资源竞争，避免堵塞，且可以定时定期执行、单线程、并发数控制，配置任务过多任务后的拒绝策
略等功能
类别
newFixedThreadPool
一个定长线程池，可控制线程最大并发数
newCachedThreadPool
一个可缓存线程池
newSingleThreadExecutor
一个单线程化的线程池，用唯一的工作线程来执行任务
newScheduledThreadPool
一个定长线程池，支持定时/周期性任务执行</code></pre><h5 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h5><pre><code>有的，可以通过Executors去进行创建，分别有：
newCachedThreadPool：创建一个可以根据需要创建新线程的线程池，如果有空闲线程，优先使用空闲的线程
newFixedThreadPool：创建一个固定大小的线程池，在任何时候，最多只有N个线程在处理任务
newScheduledThreadPool：能延迟执行、定时执行的线程池
newWorkStealingPool：工作窃取，使用多个队列来减少竞争
newSingleThreadExecutor：单一线程的线程次，只会使用唯一一个线程来执行任务，即使提交再多的任务，也都是会放到等待队列里进行等待
newSingleThreadScheduledExecutor：单线程能延迟执行、定时执行的线程池
上面这几种方式，底层还是使用ThreadPoolExecutor创建线程池，且如果使用不当，容易造成oom
newFixedThreadPool newSingleThreadExecutor允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
newCachedThreadPool newScheduledThreadPool允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</code></pre><h5 id="java线程常见的基本状态有哪些，这些状态分别是做什么的"><a href="#java线程常见的基本状态有哪些，这些状态分别是做什么的" class="headerlink" title="java线程常见的基本状态有哪些，这些状态分别是做什么的"></a>java线程常见的基本状态有哪些，这些状态分别是做什么的</h5><pre><code>常见的5种状态
创建(NEW): ⽣生成线程对象，但是并没有调⽤用该对象start(), new Thread()
就绪(Runnable)：当调⽤用线程对象的start()⽅方法，线程就进⼊入就绪状态，但是此刻线程调度还没把该线程设置为当前线程，就是没获得CPU使⽤用权。 如果线程运⾏行行后，从等待或者睡眠中回来之后，也会进⼊入就绪状态
运行(Running)
程序将处于就绪状态的线程设置为当前线程，即获得CPU使⽤用权，这个时候线程进⼊入运⾏行行状态，开始运⾏行行run⾥里里⾯面的逻辑
阻塞(Blocked)
等待阻塞：进⼊入该状态的线程需要等待其他线程作出⼀一定动作(通知或中断)，这种状态的话CPU不不会分配过来，他们需要被唤醒，可能也会⽆无限等待下去。⽐比如调⽤用wait(状态就会变成WAITING状态)，也可能通过调⽤用sleep(状态就会变成TIMED_WAITING), join或者发出IO请求，阻塞结束后线程重新进⼊入就绪状态
同步阻塞：线程在获取synchronized同步锁失败，即锁被其他线程占⽤用，它就会进⼊入同步阻塞状态
等待(WAITING)：进⼊入该状态的线程需要等待其他线程做出⼀一些特定动作（通知或中断）。
超时等待(TIMED_WAITING)：该状态不不同于WAITING，它可以在指定的时间后⾃自⾏行行返回
死亡(TERMINATED):⼀一个线程run⽅方法执⾏行行结束，该线程就死亡了了，不不能进⼊入就绪状态</code></pre><h5 id="Java线程的常⻅见⽅方法你知道多少"><a href="#Java线程的常⻅见⽅方法你知道多少" class="headerlink" title="Java线程的常⻅见⽅方法你知道多少"></a>Java线程的常⻅见⽅方法你知道多少</h5><pre><code>sleep
    属于线程Thread的⽅方法
    让线程暂缓执⾏行行，等待预计时间之后再恢复
    交出CPU使⽤用权，不不会释放锁
    进⼊入阻塞状态TIME_WAITGING，睡眠结束变为就绪Runnable
yield
    属于线程Thread的⽅方法
    t1/t2/t3
    暂停当前线程的对象，去执⾏行行其他线程
    交出CPU使⽤用权，不不会释放锁，和sleep类似
    作⽤用：让相同优先级的线程轮流执⾏行行，但是不不保证⼀一定轮流
    注意：不不会让线程进⼊入阻塞状态，直接变为就绪Runnable，只需要重新获得CPU使⽤用权
join
    属于线程Thread的⽅方法
    在主线程上运⾏行行调⽤用该⽅方法，会让主线程休眠，不不会释放已经持有的对象锁
    让调⽤用join⽅方法的线程先执⾏行行完毕，在执⾏行行其他线程
    类似让救护⻋车警⻋车优先通过
wait
    属于Object的⽅方法
    当前线程调⽤用对象的wait⽅方法，会释放锁，进⼊入线程的等待队列列
    需要依靠notify或者notifyAll唤醒，或者wait(timeout)时间⾃自动唤醒
notify
    属于Object的⽅方法
    唤醒在对象监视器器上等待的单个线程，选择是任意的
notifyAll
    属于Object的⽅方法
    唤醒在对象监视器器上等待的全部线程</code></pre><h5 id="在Java中可以有哪些⽅方法来保证线程安全"><a href="#在Java中可以有哪些⽅方法来保证线程安全" class="headerlink" title="在Java中可以有哪些⽅方法来保证线程安全"></a>在Java中可以有哪些⽅方法来保证线程安全</h5><pre><code>加锁,⽐比如synchronize/ReentrantLock
使⽤用volatile声明变量量，轻量量级同步，不不能保证原⼦子性(需要解释)
使⽤用线程安全类(原⼦子类AtomicXXX，并发容器器，同步容器器
CopyOnWriteArrayList/ConcurrentHashMap等
ThreadLocal本地私有变量量/信号量量Semaphore等</code></pre><h4 id="十四、并发编程"><a href="#十四、并发编程" class="headerlink" title="十四、并发编程"></a>十四、并发编程</h4><h4 id="十五、RabbitMQ"><a href="#十五、RabbitMQ" class="headerlink" title="十五、RabbitMQ"></a>十五、RabbitMQ</h4><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><pre><code>消息持久化的前提是：将交换器器/队列列的durable属性设置为true，表示交换器器/队列列是持久交换器器/队列列，在服务器器崩溃或重启之后不不需要重新创建交换器器/队列列（交换器器/队列列会⾃自动创建）。
如果消息想要从Rabbit崩溃中恢复，那么消息必须：
1、在消息发布前，通过把它的 “投递模式” 选项设置为2（持久）来把消息标记成持久化
2、将消息发送到持久交换器器
3、消息到达持久队列列
RabbitMQ确保持久性消息能从服务器重启中恢复的⽅式是，将它们写⼊磁盘上的⼀个持久化⽇志⽂件，当发布⼀条持久性消息到持久交换器上时，Rabbit会在消息提交到⽇志⽂件后才发送响应（如果消息路由到了⾮持久队列，它会⾃动从持久化⽇志中移除）。⼀旦消费者从持久队列中消费了⼀条持久化消息，RabbitMQ会在持久化⽇志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会⾃动重建交换器和队列（以及绑定），并重播持久化⽇志⽂件中的消息到合适的队列或者交换器上。</code></pre><h4 id="十六、Kafka"><a href="#十六、Kafka" class="headerlink" title="十六、Kafka"></a>十六、Kafka</h4><h4 id="十七、ActiveMQ"><a href="#十七、ActiveMQ" class="headerlink" title="十七、ActiveMQ"></a>十七、ActiveMQ</h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr />

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

            
            <div class="reprint1">
                <p>
                    <span class="reprint1-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://www.ldclass.club" class="b-link-green">陌生的小窝</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2021/07/07/java-mian-shi-ti/" class="b-link-green">JAVA面试题</a>
                </p>
            </div>

        </div>
    </div>

    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    /* valine 评论框增加背景图片 */
    #vcomments textarea {
        box-sizing: border-box;
        background: url("") 100% 100% no-repeat;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table,
    th,
    td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table,
    th,
    td {
        border: 0;
    }

    table tr:nth-child(2n),
    thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table,
    th,
    td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n),
    thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked),
    [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
        padding-top: 2.5em !important;
    }


    /* valine 评论框增加背景图片 */
    #vcomments textarea {
        box-sizing: border-box;
        background: url("http://www.luckyzmj.cn/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments .vwrap {
        box-sizing: border-box;
        padding: 0 0 44px;
        background-color: #F0FFF0;
    }

    #vcomments .vwrap .vheader {
        width: 80%;
        bottom: 0;
        position: absolute;
        background: #F0FFF0;
    }

    #vcomments .vinput {
        padding: 10px 15px;
        text-align: center;
    }

    #vcomments .vwrap .vheader .vinput {
        border-bottom: 0px
    }

    #vcomments .vwrap .vedit .vctrl {
        margin-top: -44px;
        right: 0;
        position: absolute;
        margin-right: -3px;
    }

    #vcomments .vwrap .vrow {
        position: absolute;
        right: 0;
        bottom: 0;
        width: 20%;
        padding-top: 0px;
    }

    #vcomments .vrow {
        font-size: 0;
        padding: 0px 0;
    }

    #vcomments .vicon {
        margin-right: 15px;
    }

    #vcomments .vrow .vcol.vcol-30 {
        display: none
    }

    #vcomments .vedit .vctrl span.vpreview-btn {
        display: none
    }

    #vcomments .vrow .vcol.vcol-70 {
        width: 100%;
    }

    #vcomments .vsubmit.vbtn {
        border-radius: 0;
        padding: 0;
        color: #fff;
        line-height: 44px;
        width: 100%;
        border: none;
        background: #4cbf30;
    }

    #vcomments .vcards .vcard .vh .vhead .vsys {
        background: #F0FFF0;
    }

    #vcomments .vcards .vcard .vh .vmeta .vat {
        font-size: 12px;
        display: block;
        margin-left: 15px;
        float: right;
        color: #fff;
        background-color: #4cbf30;
        line-height: 20px;
        padding: 0 6px;
        border-radius: 3px;
    }

    @media screen and (max-width: 520px) {
        #vcomments .vwrap .vheader .vinput {
            width: 33.33%;
            padding: 10px 5px;
        }
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <link rel="stylesheet" type="text/css" href="/libs//libs/jQuery-emoji/dist/css/jquery.emoji.css">
<script src="/libs//libs/jQuery-emoji/dist/js/jquery.emoji.min.js"></script>
<script src="/libs//libs/jQuery-emoji/dist/js/emoji.list.js"></script> -->
<script>
    // new Valine({
    //     el: '#vcomments',
    //     appId: 'yHOHzWVmf4fK0U4skbOUFs4V-gzGzoHsz',
    //     appKey: '7FQiVW3FVaXIdEc49YyCP4Lq',
    //     notify: 'false' === 'true',
    //     verify: 'true' === 'true',
    //     visitor: 'true' === 'true',
    //     avatar: 'mm',
    //     pageSize: '10',
    //     lang: 'zh-cn',
    //     placeholder: 'just go go',

    // });

    //     function parse_emoji() {
    //     jQuery(".vcontent").emojiParse({
    //       basePath: '/libs/jQuery-emoji/images/emoji',
    //       icons: emojiLists   // 注：详见 js/emoji.list.js
    //     });
    //   }

    //   setTimeout(function() {
    //     // jQuery emoji 解析
    //     parse_emoji();
    //     // jquery emoji 初始化
    //     jQuery(".veditor").emoji({
    //       showTab: true,
    //       animation: 'slide',
    //       basePath: '/libs/jQuery-emoji/images/emoji',
    //       icons: emojiLists  // 注：详见 js/emoji.list.js
    //     });
    //     jQuery(".vmore").on("click", function() {
    //       setTimeout(function() {
    //         parse_emoji();
    //       }, 500);
    //     });
    //   }, 800)

    new Valine
        ({
            el: '#vcomments',
            admin_email: '873791226@qq.com',
            appId: 'yHOHzWVmf4fK0U4skbOUFs4V-gzGzoHsz',
            appKey: '7FQiVW3FVaXIdEc49YyCP4Lq',
            path: window.location.pathname,
            comment_count: true,
            notify: 'false' === 'true',
            verify: 'true' === 'true',
            visitor: 'true' === 'true',
            avatar: 'mm',
            pageSize: '10',
            lang: 'zh-cn',
            placeholder: 'just go go',
        });
    $(document).ready(function () {
        $("#vcomments").on('click', 'span.vat', function () {
            $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
            $('textarea#veditor').focus();
        })
    }) 
</script>
<script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<script type="text/javascript">
    jinrishici.load(function (result) {
        var jrsc_plac = result.data.content + "\n「" + result.data.origin.title + "」" + result.data.origin.dynasty + " · " + result.data.origin.author
        document.getElementById("veditor").setAttribute("placeholder", jrsc_plac);
    });
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/07/14/mysql-zhu-cong-fu-zhi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="Mysql主从复制">
                        
                        <span class="card-title">Mysql主从复制</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
主从同步复制有以下几种方式：
同步复制，master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。
异步复制，master只需要完成自己的数据库操作即可，至于slaves是否收到二进制日志，是否完成操作
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-07-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/MYSQL/" class="post-category" target="_blank">
                                    MYSQL
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MYSQL/" target="_blank">
                        <span class="chip bg-color">MYSQL</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/06/26/springboot-jing-tai-zi-yuan-jia-zai/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Springboot静态资源加载">
                        
                        <span class="card-title">Springboot静态资源加载</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
静态资源加载顺序
classpath:/META-INF/resources/, classpath:/resources/, classpath:/static/, classpath:/public/

spring boot配置文件
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-06-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SpringBoot/" class="post-category" target="_blank">
                                    SpringBoot
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/SpringBoot/" target="_blank">
                        <span class="chip bg-color">SpringBoot</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFunction.js"></script>
<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script> 
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script> 
<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
 <style type="text/css">
    code[class*="language-"],
    pre[class*="language-"] {
        white-space: pre !important;
    }
</style> 
    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
            // 先关闭目录
            /* 修复文章卡片 div 的宽度. */
            let fixPostCardWidth = function (srcId, targetId) {
                let srcDiv = $('#' + srcId);
                if (srcDiv.length === 0) {
                    return;
                }

                let w = srcDiv.width();
                if (w >= 450) {
                    w = w + 21;
                } else if (w >= 350 && w < 450) {
                    w = w + 18;
                } else if (w >= 300 && w < 350) {
                    w = w + 16;
                } else {
                    w = w + 14;
                }
                $('#' + targetId).width(w);
            };

            // 切换TOC目录展开收缩的相关操作.
            const expandedClass = 'expanded';
            let $tocAside = $('#toc-aside');
            let $mainContent = $('#main-content');
            // $tocAside.removeClass(expandedClass).slideUp(500);
            // $mainContent.removeClass('l9');
            // fixPostCardWidth('artDetail', 'prenext-posts');
            $('#floating-toc-btn .btn-floating').click(function () {
                if ($tocAside.hasClass(expandedClass)) {
                    $tocAside.removeClass(expandedClass).slideUp(500);
                    $mainContent.removeClass('l9');
                } else {
                    $tocAside.addClass(expandedClass).slideDown(500);
                    $mainContent.addClass('l9');
                }
                fixPostCardWidth('artDetail', 'prenext-posts');
            });
          
    });
</script>
    

</main>


        <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&copy; 2020 DongLiu. 

            <br>
            <span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span>
            <br>

            

            
                    
                        <span id="busuanzi_container_site_pv" style='display:none'></span>
                        总访问量: <span id="busuanzi_value_site_pv" class="white-color"></span>
                    
        
                    
                        <span id="busuanzi_container_site_uv" style='display:none'></span>
                        人次&nbsp; | &nbsp;访客人数: <span id="busuanzi_value_site_uv" class="white-color"></span> 人
                    
    
            

            
                &nbsp; | &nbsp;字数统计:&nbsp;
                <span class="white-color">229.1k</span> 字
            

            
            <br>

        </div>

        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/15806679020" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>


 
    <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=873791226@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>






    <a href="http://wpa.qq.com/msgrd?v=3&uin=873791226&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>




<!-- 
    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
 --></div>

    </div>
</footer>

<div class="progress-bar"></div>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2020, 08, 10, 00, 00, 00); //北京时间2020-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已勉强运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>






        <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


        <script src="https://cdn.bootcss.com/materialize/1.0.0/js/materialize.min.js"></script>
        <script src="https://cdn.bootcss.com/masonry/4.2.2/masonry.pkgd.min.js"></script>
        <script src="https://cdn.bootcss.com/aos/3.0.0-beta.6/aos.js"></script>
        <script src="https://cdn.bootcss.com/scrollprogress/3.0.2/scrollProgress.min.js"></script>
        <script src="https://cdn.bootcss.com/lightgallery/1.6.12/js/lightgallery-all.min.js"></script>
        <script src="/js/matery.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->



        
            <script src="/libs/others/clicklove.js"></script>
        

        
            <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        

        <!-- DongLiu  add 2020.08.28 -->
        <!-- <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title =
                    "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script> -->

        <!-- 鼠标点击烟花爆炸效果  DongLiu  add 2020.09.09 -->
        

        <!-- 背景雪花飘落特效DongLiu  add 2020.09.10 -->
        
            <script type="text/javascript">
            //只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
            }
            </script>
        

        <!-- 鼠标点击文字特效 DongLiu  add 2020.09.10-->
        
            <script src="/js/wenzi.js" type="text/javascript"></script>
        

        <!-- 背景雪花飘落特效 DongLiu  add 2020.09.10 -->
        
            <script type="text/javascript">
                var windowWidth = $(window).width();
                if (windowWidth > 768) {
                    document.write('<script type="text/javascript" src="/js/xuehuapiaoluo.js"><\/script>');
                }
            </script>
        

        <!-- 在线聊天工具  DongLiu  add 2020.09.11 -->
        

        <!-- 背景 canvas-nest  DongLiu   add 2020.09.15-->
        

        <!-- 背景静止彩带  DongLiu   add 2020.09.15-->
        

        <!-- 背景动态彩带 DongLiu   add 2020.09.15-->
        

    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>